/*
DataBase Term
 - Relation = Table
 - Attribute = Field = Column = 속성 --> 일관된 데이터타입만 저장 가능
 - Tuple = Record = Row = 속성들의 집합
 - Domain : 속성이 취할 수 있는 값의 범위
 - Cardinality : Tuple의 수
 - Degree : Attribute의 수
 - Relation Schema : 속성의 이름
 - Relation Instance : Tuple의 집합

 - Key : Row를 구분하기 위한 하나 이상의 Column
   -- Primary Key : 수 많은 Record사이에서 현재 레코드의
                    유일한 특성을 갖게 하는 하나 이상의 속성
                  : 1개의 테이블에 1개의 PK만 존재
   -- Foreign Key : 1:N관계를 갖는 두 개의 테이블에서 N의 속성을 갖고 있는 테이블의 
                    Column Data는 반드시 1의 속성을 갖는 테이블의 Column Data와
                    일치시킴으로써 두 개의 테이블의 관계에서 Object Integrity와 
                    Reference Integrity을 유지하도록 한다.
                
                    
DataBase Normalization
   : 데이터의 중복으로 인한 이상(Anomaly) 현상 제거
   1. Insert Anomaly
      : 새로운 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
   2. Update Anomaly
      : 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 문제 
   3. Deletion Anomaly
      : 데이터를 삭제할 경우 데이터가 포함된 레코드가 삭제되므로 삭제하지 말아야 할
        데이터도 함께 삭제되는 문제
*/
SELECT * FROM DBA_USERS;

/* 2020-10-19 User Creation 
    Syntax____
    CREATE USER [USER_NAME]
    IDENTIFIED BY "[PASSWORD]";
    
    PROCESS
     - USER CREATION
     - GRANT PRIVILEAGE
    EXEC
     1. LOCAL WORK
     2. LOCAL SHUTDOWN --> SERVER WORK
*/
CREATE USER HOONZZANG
IDENTIFIED BY "7777"; --> LACKS CREATE SESSION PRIVILEAGE 
-- DCL : GRANT[REVOKE] [PRIV_NAME | ROLE: 권한의 집합]
GRANT CREATE SESSION TO HOONZZANG;  -- CONNECT
REVOKE CREATE SESSION FROM HOONZZANG;

-- DROP USER
DROP USER HOONZZANG;

/* DBA ACCOUNT CREATION 
    SYS --> HOONZZANG :: 8888 :: DBA ROLE
   DEV ACCOUNT CREATION 
    DBA --> HOON :: 0000 :: CONNECT, RESOURCE ROLE
*/
-- DBA :: <- SYS
CREATE USER HOONZZANG
IDENTIFIED BY "8888";
GRANT DBA TO HOONZZANG;

-- DEV :: <-- DBA
CREATE USER HOON
IDENTIFIED BY "0000";
GRANT CONNECT, RESOURCE TO HOON;

-- USER CHECK
SELECT * FROM DBA_USERS;

-- DROP ANONYMOUS ACCOUNT
DROP USER ANONYMOUS;

-- 객체 권한 조회
SELECT * FROM USER_TAB_PRIVS;
SELECT * FROM USER_TAB_PRIVS_MADE;
SELECT * FROM USER_TAB_PRIVS_RECD;

-- ROLE에 부여된 시스템 || 객체 권한
SELECT * FROM ROLE_SYS_PRIVS WHERE ROLE = 'DBA';
SELECT * FROM ROLE_TAB_PRIVS WHERE ROLE = 'RESOURCE';
SELECT * FROM USER_ROLE_PRIVS;

/* USER CREATION
    SYN___
    CREATE USER [USER_NAME] IDENTIFIED BY "[PASSWORD]"
    *DEFAULT TABLESPACE [TBS_NAME]
    TEMPORATY TABLESPACE [TBS_NAME]
    *QUOTA [INTEGER M | UNLIMITED] ON [TBS_NAME];
*/

/* DBA :: USERS  :: UNLIMITED */
ALTER USER HOONZZANG
DEFAULT TABLESPACE USERS
QUOTA UNLIMITED ON USERS;

/* DEV :: USERS  :: UNLIMITED */
ALTER USER HOON
DEFAULT TABLESPACE USERS
QUOTA UNLIMITED ON USERS;

SELECT * FROM DBA_USERS;

/* 테이블 설계 시 알아야 할 내용 
   0. PROCESS 
      ENTITY 도출 --> ENTITY 배치 --> ENTITY RELATIONSHIP
      
   1. ENTITY
      - KEY ENTITY
      - MAIN ENTITY
      - ACTION ENTITY
      - PRODUCTION ENTITY
   2. NORMALIZATION
   3. ATTRIBUTE
   4. IDENTIFIER
   5. RELATIONSHIP
   6. DOMAIN
*/

/* 2020-10-20 :: TABLE
    PROCESS
      1. CREATE :: ATTRIBUTES 
      2. CREATE :: TABLESPACE 
      3. ALTER  :: CONSTRAINTS
      4. CREATE :: SYNONYM  --> 소유주만 사용가능
                :: PUBLIC SYNONYM --> 소유주 뿐만 아니라 권한을 부여받은 계정도 사용
                   --> DML구문에서만 사용 가능 
      5. GRANT  :: OBJECT PRIVILEGE
      
    SYNTAX____________
    CREATE TABLE [TAB_NAME](
      [COL_NAME]    [DATA-TYPE]     [PROPERTY],
          :              :               :    ,
      [COL_NAME]    [DATA-TYPE]     [PROPERTY],
      CONSTRAINT 
    )TABLESPACE [TBS_NAME];
*/
-- 1. DBA :: STORE TABLE(ST)
CREATE TABLE STORES(
 ST_CODE    NCHAR(4),
 ST_NAME    NVARCHAR2(100),
 ST_ADDR    NVARCHAR2(100)
)TABLESPACE USERS;

/* CONSTRAINTS 
    : 특정 테이블의 특정 컬럼에 입력 제한 용도
    1. PRIMARY KEY
       - 하나의 테이블에 한 개의 PK 지정 가능
       - UNIQUE
       - NOT NULL
*/
-- ADD
ALTER TABLE STORES
ADD CONSTRAINT ST_CODE_PK  PRIMARY KEY(ST_CODE);
-- DROP
ALTER TABLE STORES
DROP CONSTRAINT ST_CODE_PK;

-- DATA INSERT
INSERT INTO STORES(ST_CODE, ST_NAME, ST_ADDR) 
VALUES('I001', '훈이네마켓', '인천시 미추홀구 학익동');
INSERT INTO STORES(ST_CODE, ST_NAME, ST_ADDR) 
VALUES('I001', '훈이네마켓', '인천시 미추홀구 학익동'); --> X
INSERT INTO STORES(ST_CODE, ST_NAME, ST_ADDR) 
VALUES( NULL, '훈이네마켓', '인천시 미추홀구 학익동');  --> X

   /* ALTER 의 활용 
    SUB COMMAND :   ADD --> 컬럼 추가
                    ADD CONSTRAINT --> 제약조건 추가
                    DROP COLUMN --> 컬럼 제거
                    DROP CONSTRAINT --> 제약조건 제거
                    MODIFY  --> 컬럼 수정
   */
   -- 컬럼 수정(DATA TYPE, PROPERTY)
   ALTER TABLE STORES MODIFY ST_ADDR NOT NULL;
   -- 컬럼 제거
   ALTER TABLE STORES DROP COLUMN ST_ADDR;
   -- 컬럼 추가
   ALTER TABLE STORES ADD ST_ADDR  NVARCHAR2(100);
   -- -- 컬럼 수정(DATA TYPE, PROPERTY)
   UPDATE STORES SET ST_ADDR = '인천광역시 미추홀구 학익동' WHERE ST_CODE = 'I001';
   ALTER TABLE STORES MODIFY ST_ADDR NOT NULL;
   
/* SYNONYM
    : 특정 테이블의 호출 이름을 별칭으로 가능
    : SYNONYM을 CREATE한 계정만이 사용 가능
    : DML구문(INSERT, UPDATE, DELETE, SELECT)사용 가능
    SYNTAX________
    CREATE SYNONYM [TAB_ALIAS] FOR [OBJECT]
*/
CREATE SYNONYM ST FOR HOONZZANG.STORES;
DROP SYNONYM ST;
SELECT * FROM ST;

/* OBJECT PRIVILEGE :: 개체 소유자
    SYNTAX___________
    GRANT [OBJ_PRIV_NAME], ... , [OBJ_PRIV_NAME] ON [OBJECT] TO [SCHEMA]
*/
GRANT SELECT ON HOONZZANG.STORES TO HOON;
-- HOON조회
SELECT * FROM HOONZZANG.STORES;

--> DBA : PUBLIC SYNONYM 
CREATE PUBLIC SYNONYM ST FOR HOONZZANG.STORES;
   --> HOON 사용
   SELECT * FROM ST;
   
-- 2. DBA :: GOODS TABLE(GO)
CREATE TABLE GOODS(
 GO_CODE        NCHAR(4),
 GO_NAME        NVARCHAR2(50),
 GO_PRICE       NUMBER(7,0),
 GO_COMMENTS    NVARCHAR2(100)
)TABLESPACE USERS;

 -- PROPERTY
 ALTER TABLE GOODS
 MODIFY GO_NAME NOT NULL
 MODIFY GO_PRICE DEFAULT 0;
 
 -- 2-3. CONSTRAINTS 
 ALTER TABLE GOODS
 ADD CONSTRAINT GO_CODE_PK   PRIMARY KEY(GO_CODE);
 
 -- 2-4. SYNONYM
 CREATE PUBLIC SYNONYM GO FOR HOONZZANG.GOODS;
 
 -- 2-5. GRANT 
 GRANT INSERT, SELECT ON HOONZZANG.GOODS TO HOON;
 
 -- 2-6. TEST DATA  <-- DEV
 INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) 
 VALUES('1001', '새우깡', 1500, '일반');
 INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) 
 VALUES('1002', '새우깡', 3000, '노래방');
 
 SELECT * FROM GO;
 
-- 3. DBA :: CUSTOMER TABLE(CM)
CREATE TABLE CUSTOMER(
 CM_CODE    NCHAR(5),
 CM_NAME    NVARCHAR2(5)
)TABLESPACE USERS;

 -- PROPERTY
 
 -- 3-3. CONSTRAINTS 
 ALTER TABLE CUSTOMER
 ADD CONSTRAINT CM_CODE_PK  PRIMARY KEY(CM_CODE);
 
 -- 3-4. SYNONYM
 CREATE PUBLIC SYNONYM CM FOR HOONZZANG.CUSTOMER;
 
 -- 3-5. GRANT
 GRANT INSERT,SELECT ON HOONZZANG.CUSTOMER TO HOON;
 
 -- 3-6. TEST DATA  <-- DEV
 INSERT INTO CM(CM_CODE, CM_NAME) VALUES('C0001', '다사가');
 INSERT INTO CM(CM_CODE, CM_NAME) VALUES('C0002', '더없어');
 INSERT INTO CM(CM_CODE, CM_NAME) VALUES('C0003', '또왔어');
 INSERT INTO CM(CM_CODE, CM_NAME) VALUES('C0000', '비회원');
 
 SELECT * FROM CM;
 
 COMMIT;
 
 -- CM_PHONE ADD :: DBA
 ALTER TABLE CUSTOMER
 ADD CM_PHONE   NCHAR(11);
 -- CM_PHONE UNIQUE CONSTRAINT ADD  :: DBA
 ALTER TABLE CUSTOMER
 ADD CONSTRAINT CM_PHONE_UK     UNIQUE(CM_PHONE);
 
 GRANT UPDATE ON HOONZZANG.CUSTOMER TO HOON;
 -- TEST DATA :: DEV
 UPDATE CM SET CM_PHONE = '01056808050' WHERE CM_CODE = 'C0001';
 UPDATE CM SET CM_PHONE = '01056808050' WHERE CM_CODE = 'C0002';  --> X
 
 SELECT * FROM CM;
 
 
-- EMPOLYEES TABLE(EM) :: DBA
CREATE TABLE EMPLOYEES(
 EM_STCODE      NCHAR(4),
 EM_CODE        NCHAR(4),
 EM_PWD         NVARCHAR2(10),
 EM_NAME        NVARCHAR2(5)
)TABLESPACE USERS;

 -- PROPERTY
 ALTER TABLE EMPLOYEES
 MODIFY EM_PWD  NOT NULL
 MODIFY EM_NAME NOT NULL;
 
 -- CONSTRAINTS
 ALTER TABLE EMPLOYEES
 ADD CONSTRAINT EM_STCODE_CODE_PK PRIMARY KEY(EM_STCODE, EM_CODE)
 ADD CONSTRAINT EM_STCODE_FK    FOREIGN KEY(EM_STCODE) REFERENCES STORES(ST_CODE);
 
 -- SYNONYM
 CREATE PUBLIC SYNONYM "EM" FOR HOONZZANG.EMPLOYEES;
 
 -- GRANT 
 GRANT ALL ON HOONZZANG.EMPLOYEES TO HOON;
 
 -- TEST DATA :: DEV
 INSERT INTO "EM"(EM_STCODE, EM_CODE, EM_PWD, EM_NAME) 
 VALUES('I001', 'E001', '1234', '다팔아');
 INSERT INTO "EM"(EM_STCODE, EM_CODE, EM_PWD, EM_NAME) 
 VALUES('I002', 'E002', '1234', '다팔아');  --> X
 
 SELECT * FROM "EM";
 COMMIT;
 
-- TABLE CREATE :: STOCK
CREATE TABLE STOCK(
SC_GOCODE   NCHAR(4),
SC_CODE     DATE,
SC_STOCKS   NUMBER(3,0),
SC_EXPIRE   DATE
)TABLESPACE USERS;

-- PROPERTY
ALTER TABLE STOCK
MODIFY SC_STOCKS DEFAULT 0
MODIFY SC_EXPIRE NOT NULL;

-- CONSTRAINT 
ALTER TABLE STOCK
ADD CONSTRAINT SC_GOCODE_CODE_PK PRIMARY KEY (SC_GOCODE, SC_CODE)
ADD CONSTRAINT SC_GOCODE_FK FOREIGN KEY (SC_GOCODE) REFERENCES HOONZZANG.GOODS(GO_CODE);

-- SYNONYM
CREATE PUBLIC SYNONYM SC FOR HOONZZANG.STOCK;

-- GRANT
GRANT ALL ON SC TO HOON;

-- INSERT
INSERT INTO SC (SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) 
VALUES ('1001',SYSDATE,10,'20221020');

-- COMMIT
COMMIT;

-- TEST
SELECT * FROM USER_TAB_COLS WHERE TABLE_NAME = 'STOCK';

SELECT * FROM DBA_TAB_PRIVS WHERE GRANTEE = 'HOON';

-- CHECK
SELECT * FROM HOONZZANG.STORES;
SELECT * FROM USER_TABLES;
SELECT * FROM USER_TAB_COLS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';


/* 2020-10-21 팀실습 
1. SYS___ 
   SELECT * FROM DBA_USERS;
   DROP USER [USER_NAME] CASCADE;
2. SYS___
   DBA_TEAM 생성 및 권한 부여
3. DBA____
   STORE, GOODS, CUSTOMER, EMPLOYEE, STOCK 테이블 생성 후 
     PROPERTY, CONSTRIANT, PUBLIC SYNONYM 생성
4. DBA_____
   DEV_TEAM 계정 생성 후 테이블 접근(SELECT) 권한 부여
   DEV1_TEAM :: STORE, EMPLOYEE :: INSERT, UPDATE 
   DEV2_TEAM :: GOODS, STOCK :: INSERT, UPDATE 
   DEV3_TEAM ::  
   DEV4_TEAM :: CUSTOMER :: INSERT, UPDATE

5. CHECK

-- USER CHECK :: DBA
SELECT * FROM DBA_USERS;

-- TABLE CHECK :: DBA
SELECT * FROM USER_TABLES;
SELECT * FROM USER_TAB_COLS WHERE TABLE_NAME = '';
SELECT * FROM USER_CONSTRAINT WHERE TABLE_NAME = '';

-- PRIVILEGES :: DBA
SELECT * FROM USER_TAB_PRIVS WHERE GRANTEE = 'HOON';
SELECT * FROM USER_TAB_PRIVS_MADE WHERE GRANTEE = 'HOON';

-- PRIVILEGES :: DEV
SELECT * FROM USER_TAB_PRIVS_RECD;

*/
GRANT SELECT, INSERT, UPDATE ON HOONZZANG.STORES TO HOON;
GRANT SELECT, INSERT, UPDATE ON HOONZZANG.GOODS TO HOON; 
GRANT SELECT, INSERT, UPDATE ON HOONZZANG.CUSTOMER TO HOON;
GRANT SELECT, INSERT, UPDATE ON HOONZZANG.EMPLOYEES TO HOON; 
GRANT SELECT, INSERT, UPDATE ON HOONZZANG.STOCK TO HOON; 

/* 2020-10-21 */
-- ORDERS(OD) :: DBA
CREATE TABLE ORDERS(
 OD_CODE    DATE,
 OD_EMSTCODE NCHAR(4),
 OD_EMCODE  NCHAR(4),
 OD_CMCODE  NCHAR(5),
 OD_STATE   NCHAR(1)
)TABLESPACE USERS;

  -- PROPERTY
  ALTER TABLE ORDERS
  MODIFY OD_EMCODE NOT NULL
  MODIFY OD_EMSTCODE NOT NULL
  MODIFY OD_CMCODE NOT NULL
  MODIFY OD_STATE NOT NULL;

  -- CONSTRAINTS
  ALTER TABLE ORDERS
  ADD CONSTRAINT OD_CODE_PK   PRIMARY KEY(OD_CODE) 
  ADD CONSTRAINT OD_EMSTCODE_EMCODE_FK FOREIGN KEY(OD_EMSTCODE, OD_EMCODE) REFERENCES EMPLOYEES(EM_STCODE, EM_CODE)
  ADD CONSTRAINT OD_CMCODE_FK FOREIGN KEY(OD_CMCODE) REFERENCES CUSTOMER(CM_CODE);

  -- SYNONYM
  CREATE PUBLIC SYNONYM OD FOR HOONZZANG.ORDERS;

  -- GRANT
  GRANT SELECT, INSERT, UPDATE ON HOONZZANG.ORDERS TO HOON;

-- ORDERDETAIL(OT) :: DBA
CREATE TABLE ORDERDETAIL(
 OT_ODCODE   DATE,
 OT_GOCODE  NCHAR(4),
 OT_QTY     NUMBER(2,0),
 OT_STATE   NCHAR(1)
)TABLESPACE USERS;

  -- PROPERTY
  ALTER TABLE ORDERDETAIL
  MODIFY OT_QTY DEFAULT 0
  MODIFY OT_STATE NOT NULL;
  
  -- CONSTRAINTS
  ALTER TABLE ORDERDETAIL
  ADD CONSTRAINT OT_ODCODE_GOCODE_PK    PRIMARY KEY(OT_ODCODE, OT_GOCODE)
  ADD CONSTRAINT OT_ODCODE_FK   FOREIGN KEY(OT_ODCODE) REFERENCES ORDERS(OD_CODE)
  ADD CONSTRAINT OT_GOCODE_FK   FOREIGN KEY(OT_GOCODE) REFERENCES GOODS(GO_CODE);
  
  -- SYNONYM
  CREATE PUBLIC SYNONYM OT FOR HOONZZANG.ORDERDETAIL;
  
  -- GRANT
  GRANT SELECT, INSERT, UPDATE ON HOONZZANG.ORDERDETAIL TO HOON;
  
  
-- POINTS(PO) :: DBA
CREATE TABLE POINTS(
 PO_CMCODE  NCHAR(5),
 PO_ODCODE  DATE,
 PO_STATE   NUMBER(1,0),
 PO_AMOUNT  NUMBER(6,0)
)TABLESPACE USERS;

  -- PROPERTY
  ALTER TABLE POINTS
  MODIFY PO_STATE   NOT NULL
  MODIFY PO_AMOUNT  DEFAULT 0;
  
  -- CONSTRAINTS
  ALTER TABLE POINTS
  ADD CONSTRAINT PO_CMCODE_ODCODE_PK    PRIMARY KEY(PO_CMCODE, PO_ODCODE)
  ADD CONSTRAINT PO_CMCODE_FK   FOREIGN KEY(PO_CMCODE) REFERENCES CUSTOMER(CM_CODE)
  ADD CONSTRAINT PO_ODCODE_FK   FOREIGN KEY(PO_ODCODE) REFERENCES ORDERS(OD_CODE);
  
  -- SYNONYM
  CREATE PUBLIC SYNONYM PO FOR HOONZZANG.POINTS;
  
  -- GRANT
  GRANT SELECT, INSERT, UPDATE ON HOONZZANG.POINTS TO HOON;
  
/* 날짜데이터의 DEFAULT VALUE 지정 
   STOCK :: SC_CODE :: SYSDATE
   ORDERS:: OD_CODE :: SYSDATE
*/
SELECT SYSDATE FROM DUAL;

-- DBA --> DEV  :: GRANT - ALTER
GRANT ALTER ON HOONZZANG.STORES TO HOON;
GRANT ALTER ON HOONZZANG.EMPLOYEES TO HOON;
GRANT ALTER ON HOONZZANG.CUSTOMER TO HOON;
GRANT ALTER ON HOONZZANG.GOODS TO HOON;
GRANT ALTER ON HOONZZANG.STOCK TO HOON;
GRANT ALTER ON HOONZZANG.ORDERS TO HOON;
GRANT ALTER ON HOONZZANG.ORDERDETAIL TO HOON;
GRANT ALTER ON HOONZZANG.POINTS TO HOON;

-- ALTER권한을 가진 DEV가 실행
ALTER TABLE HOONZZANG.STOCK MODIFY SC_CODE DEFAULT SYSDATE;
ALTER TABLE HOONZZANG.ORDERS MODIFY OD_CODE DEFAULT SYSDATE;

/* 2020-10-21 */
/* DDL : DATA DEFINITION LANGUAGE
         : CREATE, ALTER, DROP
   DCL : DATA CONTROL LANGUAGE
         : GRANT, REVOKE 
   DML : DATA MANIPULATION LANGUAGE
         : INSERT, UPDATE, DELETE
 (S)QL : QUERY LANGUAGE
         : SELECT 
*/
/* INSERT INTO ~
    SYN_____
    INSERT INTO [TAB_NAME]([COL1_NAME], ..., [COLn_NAME]) 
    VALUES(VALUE1, ..., VALUEn);
    
    IMPORTANCE 
      :: RELATION이 설정되어 있다면 PARENT TABLE부터 CHILD TABLE 순서로 INSERT 수행
*/
SELECT * FROM USER_TAB_COLS WHERE TABLE_NAME = 'EMPLOYEES';

/* DML :: UPDATE ~ SET 
    SYNTAX__________
    UPDATE [TAB_NAME] SET [COL_NAME] = [VALUE];
    UPDATE [TAB_NAME] SET [COL_NAME] = [VALUE] WHERE [COL_NAME] [COMPARE] [VALUE] ;
*/
SELECT * FROM PO;
UPDATE PO SET PO_AMOUNT = 1000;
ROLLBACK;

UPDATE PO SET PO_AMOUNT = 10000 WHERE PO_CMCODE = 'C0010';


/* 3번 : ORDERS & ORDERDETAIL UPDATE 
    SELECT * FROM OD;
    SELECT * FROM OT;
*/  
UPDATE OD SET OD_CODE = SYSDATE -1 WHERE OD_CODE = '20201021154248';

/* DELETE 
    SYNTAX___________
    DELETE FROM [TAB_NAME];
    DELETE FROM [TAB_NAME] WHERE [COL_NAME] [COMPARE] [VALUE];
*/

/* 2020-10-22 SELECT 
    SYNTAXA__________
    5 * SELECT      [COL] AS "[ALIAS]", ..., [COL] AS "ALIAS"
    1 * FROM        [TAB | VIEW | INLINE-VIEW]
    2 * WHERE       [CONDITION]
    3   GROUP BY    [COL], ..., [COL]
    4   HAVING      [GROUP CONDITION]
    6   ORDER BY    [COL][ASC|DESC], ..., [COL][ASC|DESC]
*/
/* WHERE 
    COMPARATIVE OPERATOR :: > >= = !=(<>) < <= 
    COMBINED OPERATOR :: AND, OR
    ARITHMETIC OPERATOR :: + - * /
    SELECT OPERATOR :: IN(LIST), LIKE, IS NULL, NOT
*/
-- 특정 직원정보 검색
SELECT  EM_STCODE AS "STCODE", 
        EM_CODE AS "EMCODE", 
        EM_NAME AS "EMNAME", 
        EM_LEVEL AS "LEVEL" 
FROM EM
WHERE EM_STCODE = 'I001' AND EM_CODE = '1001'; 

-- 모든 상품 검색 QUERY
SELECT  GO_CODE AS GOCODE, 
        GO_NAME AS GONAME,
        GO_PRICE AS GOPRICE,
        GO_COMMENTS AS GOCOMMENTS
FROM GO;

-- 특정 상품 검색 QUERY
SELECT  GO_CODE AS GOCODE, 
        GO_NAME AS GONAME,
        GO_PRICE AS GOPRICE,
        GO_COMMENTS AS GOCOMMENTS
FROM GO
WHERE GO_CODE = '1001';

--
SELECT 
FROM OT
WHERE OT_ODECODE = '' AND  OT_GOCODE = '';

SELECT 
FROM OT
WHERE OT_ODECODE = '' AND  OT_GOCODE = '';
SELECT *
FROM GO
WHERE GO_CODE IN(SELECT DISTINCT OT_GOCODE FROM OT);

SELECT *
FROM GO
WHERE GO_CODE = '1001' OR GO_CODE = '2001' OR GO_CODE = '3001';


-- IS NULL
CREATE TABLE TESTS(
    T_CODE      NCHAR(1),
    T_PRICE     NUMBER(6,0),
    T_QTY       NUMBER(2,0)
)TABLESPACE USERS;

INSERT INTO TESTS(T_CODE, T_PRICE, T_QTY) VALUES('1', 100, 1);
INSERT INTO TESTS(T_CODE, T_PRICE, T_QTY) VALUES('2', 200, NULL);
INSERT INTO TESTS(T_CODE, T_PRICE, T_QTY) VALUES('3', NULL, 10);
INSERT INTO TESTS(T_CODE, T_PRICE, T_QTY) VALUES('4', 400, 10);
INSERT INTO TESTS(T_CODE, T_PRICE, T_QTY) VALUES('5', NULL, NULL);
INSERT INTO TESTS(T_CODE, T_PRICE, T_QTY) VALUES('6', 600, 5);
INSERT INTO TESTS(T_CODE, T_PRICE, T_QTY) VALUES('7', 700, 7);

SELECT * FROM TESTS;
-- 금액(T_PRICE * T_QTY)이 1000이상인 레코드 출력
SELECT *
FROM TESTS
WHERE (T_PRICE*T_QTY) >= 1000;

SELECT T_CODE, T_PRICE, T_QTY, COALESCE(T_PRICE*T_QTY, T_PRICE, T_QTY, 1)
FROM TESTS;

SELECT *
FROM TESTS
WHERE T_PRICE IS NOT NULL;

/* LIKE를 이용한 검색 
    WILD CARD :: % : 모든 문자를 대체
              :: _ : 하나의 문자를 대체
*/

SELECT * 
FROM CM
--WHERE CM_NAME LIKE '%김%';
-- APLLICATION
WHERE CM_NAME LIKE '%' || '김' || '%';


SELECT * 
FROM CM
WHERE CM_NAME LIKE '김%';
SELECT * 
FROM CM
WHERE CM_NAME LIKE '김____';

SELECT *
FROM CM
WHERE CM_CODE LIKE '%' || '05' || '%' OR
      CM_NAME LIKE '%' || '05' || '%' OR
      CM_PHONE LIKE '%' || '05' || '%';

SELECT *
FROM (SELECT CM_CODE || CM_NAME || CM_PHONE AS FULLTEXT FROM CM)
WHERE FULLTEXT LIKE '%' || '05' || '%';


/* 2020-10-23 
    ORACLE FUNCTION
     - NUMERIC FUNCTIONS
       : ABS(n), CEIL(n), FLOOR(n), MOD(n), ROUND(n,m), TRUNC(n,m)
     - CHARACTER FUNCTIONS
       : CONCAT(C1, C2), INITCAP(C),  LOWER(C), UPPER(C), SUBSTR(C, m, n)
         LENGTH(C), REPLACE(C, c1, c2), INSTR(C, c, m, n)
     - DATETIME FUNCTIONS
       SYSDATE, SYSDATE +(-) NU, ADD_MONTH(D, NU), MONTHS_BETWEEN(D,D)
       LAST_DAY(D), NEXT_DAY(D, NU)
     - * CONVERSION FUNCTIONS
       : TO_CHAR(NU), TO_CHAR(NU, F), TO_CHAR(D, F), 
         TO_DATE(C, F), TO_NUMBER(C)
*/
SELECT SYSDATE, SYSDATE + 1, ADD_MONTHS(SYSDATE, 3), LAST_DAY(SYSDATE),
    NEXT_DAY(SYSDATE, 3) FROM DUAL;
SELECT TO_CHAR(10000000, 'L99,999,999'), TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') FROM DUAL;
SELECT TO_DATE('201023120000', 'YYMMDDHH24MISS') FROM DUAL;

SELECT INSTR('ICIAOKICIAONICIAOK', 'OK', 6), INSTR('ICIAOKICIAONICIAOK', 'OK', 2,2) FROM DUAL;
SELECT CONCAT(CONCAT('IC', 'IA'), 'OK'), 'IC' || 'IA' || 'OK' FROM DUAL;
SELECT CEIL(1.52), FLOOR(1.52) FROM DUAL;
SELECT 10/3, MOD(10,3) FROM DUAL;
SELECT ROUND(1.5264, 0), ROUND(1.5264, 1), ROUND(1.5264, -1) FROM DUAL;
SELECT ROUND(1205, -1), TRUNC(1205, -1) FROM DUAL;

/* JOIN 
    - 두 개의 테이블에 존재하는 데이터를 하나의 테이블로 보여주는 기술
    - VIEW와 함께 활용
      -- 두 개의 테이블에 공통된 컬럼(DATA-TYPE)이 존재 해야 사용
      -- 테이블 ALIAS를 활용하여 쉽게 접근 가능
    1. INNER JOIN
      -- 공통된 컬럼의 데이터를 비교하여 정확하게 일치하는 레코드만 추출
    2. OUTER JOIN
    
    SYNTAX______________
    SELECT [TAB ALIAS].[COL], ..., [TAB ALIAS].[COL]
    FROM [TAB] [ALIAS] INNER JOIN [TAB] [ALIAS] ON [JOIN-CONDITION]
    WHERE [TAB ALIAS].[COL] [COMPARE] [VALUE]
*/
-- JOIN의 활용
SELECT  GO.GO_CODE AS GOCODE,
        GO.GO_NAME AS GONAME, 
        GO.GO_PRICE AS GOPRICE,
        SC.SC_EXPIRE AS SCEXPIRE
FROM GO INNER JOIN SC
ON GO.GO_CODE = SC.SC_GOCODE;

SELECT * FROM OT;

-- 반품 가능 품목 리스트
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        GO.GO_PRICE AS GOPRICE,
        OT.OT_QTY AS OTQTY,
        GO.GO_PRICE * OT.OT_QTY AS AMOUNT
FROM OT INNER JOIN GO
ON OT.OT_GOCODE = GO.GO_CODE
WHERE OT_STATE != 'R';

SELECT * FROM OT;
SELECT * FROM GO;



 -- 특정 반품 가능 품목 리스트를 가져오기 
 SELECT * FROM OD; 
 SELECT OD.OD_EMCODE AS EMCODE, 
        "EM".EM_NAME AS EMNAME,
        OD.OD_CMCODE AS CMCODE,
        CM.CM_NAME AS CMNAME,
        OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        GO.GO_PRICE AS GOPRICE,
        OT.OT_QTY AS OTQTY,
        GO.GO_PRICE * OT.OT_QTY AS AMOUNT
FROM OT INNER JOIN OD ON OT.OT_ODCODE = OD.OD_CODE    
        INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
        INNER JOIN "EM" ON OD.OD_EMCODE = "EM".EM_CODE
        INNER JOIN CM ON OD.OD_CMCODE = CM.CM_CODE;
--WHERE OD.OD_CODE = '20201013115001' AND OT_STATE != 'R';


-- VIEW의 활용
CREATE OR REPLACE VIEW GOODSINFO
AS 
 SELECT OD.OD_CODE AS ODCODE,
        OD.OD_EMCODE AS EMCODE, 
        "EM".EM_NAME AS EMNAME,
        OD.OD_CMCODE AS CMCODE,
        CM.CM_NAME AS CMNAME,
        OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        GO.GO_PRICE AS GOPRICE,
        OT.OT_QTY AS OTQTY,
        GO.GO_PRICE * OT.OT_QTY AS AMOUNT,
        OT.OT_STATE AS OTSTATE
FROM OT INNER JOIN OD ON OT.OT_ODCODE = OD.OD_CODE    
        INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
        INNER JOIN "EM" ON OD.OD_EMCODE = "EM".EM_CODE
        INNER JOIN CM ON OD.OD_CMCODE = CM.CM_CODE;
        
        
SELECT * 
FROM GOODSINFO
WHERE ODCODE = '20201013115001' AND OTSTATE != 'R';
SELECT * FROM EM;

/* 직원 관리 */
CREATE OR REPLACE VIEW EMPINFO
AS
SELECT  ST.ST_CODE AS STCODE, 
        ST.ST_NAME AS STNAME,
        "EM".EM_CODE AS EMCODE,
        "EM".EM_NAME AS EMNAME,
        "EM".EM_LEVEL AS EMLEVEL
FROM "EM" INNER JOIN ST ON "EM".EM_STCODE = ST.ST_CODE;

-- 1. 특정 매장의 직원리스트 출력
/*-------------------------------
 매장명     직원명     직원등급
--------------------------------*/
-- VIEW의 활용
SELECT STNAME, EMNAME, EMLEVEL
FROM EMPINFO WHERE STCODE = 'I001';

-- INLIN-VIEW 
SELECT STNAME, EMNAME, EMLEVEL
FROM (SELECT ST.ST_CODE AS STCODE, 
             ST.ST_NAME AS STNAME,
            "EM".EM_NAME AS EMNAME,
            "EM".EM_LEVEL AS EMLEVEL
      FROM "EM" INNER JOIN ST ON "EM".EM_STCODE = ST.ST_CODE)
WHERE STCODE = 'I001';

SELECT * FROM EM;

-- 2. 특정 직원코드를 입력받아 직원정보 출력
/*-------------------------------
 매장명     직원명     직원등급
  ST         EM         EM
--------------------------------*/
SELECT STNAME, EMNAME, EMLEVEL
FROM EMPINFO WHERE EMCODE = '1001';



/* 판매 관리 */
CREATE OR REPLACE VIEW SALESINFO
AS
SELECT  ST.ST_CODE AS STCODE,
        ST.ST_NAME AS STNAME,
        "EM".EM_CODE AS EMCODE,
        "EM".EM_NAME AS EMNAME,
        OD.OD_CODE AS ODCODE,
        OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        GO.GO_PRICE AS GOPRICE,
        OT.OT_QTY AS QTY,
        GO.GO_PRICE * OT.OT_QTY AS AMOUNT
FROM OT INNER JOIN OD ON OT.OT_ODCODE = OD.OD_CODE
        INNER JOIN "EM" ON OD.OD_EMCODE = "EM".EM_CODE
        INNER JOIN ST ON ST.ST_CODE = "EM".EM_STCODE
        INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;

--3. 특정 직원코드를 입력받아 한 달간 판매 리스트 출력
/*------------------------------------------------
 매장명     직원명     주문코드   상품명   수량   금액
   ST        EM       OD, OT     GO     OT      
 ST_CODE   EM_CODE   OT_ODCODE         OT_QTY
 ST_NAME   EM_NAME   OT_GOCODE
--------------------------------------------------*/
SELECT STNAME, EMNAME, ODCODE, GONAME, QTY, AMOUNT 
FROM SALESINFO
WHERE EMCODE = '1001' AND 
      ODCODE >= ADD_MONTHS(SYSDATE, -1);
      --TO_CHAR(ODCODE, 'YYYYMMDD') >= TO_CHAR(ADD_MONTHS(SYSDATE, -1), 'YYYYMMDD');

-- INLINE-VIEW의 활용
-- 1. 직원정보
SELECT  ST.ST_CODE,
        ST.ST_NAME,
        EM.EM_CODE,
        EM.EM_NAME       
FROM ST INNER JOIN EM ON ST.ST_CODE = EM.EM_STCODE;

-- 2. 판매 정보
SELECT  OT.OT_ODCODE,
        OT.OT_GOCODE,
        OT.OT_QTY
FROM OT;
 -- 2-1 상품명과 단가를 조회하기 위한 GOODS테이블과의 조인
 SELECT  OT.OT_ODCODE,
        OT.OT_GOCODE,
        GO.GO_NAME,
        GO.GO_PRICE,
        OT.OT_QTY,
        GO.GO_PRICE * OT.OT_QTY
 FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;

-- 3. 직원정보 판매 정보 조인
SELECT EI.ST_NAME, 
       EI.EM_CODE, 
       EI.EM_NAME,
       OD.OD_CODE,
       SI.GO_NAME,
       SI.GO_PRICE,
       SI.OT_QTY,
       SI.GO_PRICE * SI.OT_QTY
FROM (SELECT  ST.ST_CODE,
        ST.ST_NAME,
        EM.EM_CODE,
        EM.EM_NAME       
      FROM ST INNER JOIN EM ON ST.ST_CODE = EM.EM_STCODE) EI
INNER JOIN OD ON EI.ST_CODE = OD.OD_EMSTCODE AND EI.EM_CODE = OD.OD_EMCODE
INNER JOIN (SELECT  OT.OT_ODCODE,
                    OT.OT_GOCODE,
                    GO.GO_NAME,
                    GO.GO_PRICE,
                    OT.OT_QTY,
                    GO.GO_PRICE * OT.OT_QTY
            FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE) SI
            ON SI.OT_ODCODE = OD.OD_CODE
WHERE EI.EM_CODE = '1001' AND 
      OD.OD_CODE >= ADD_MONTHS(SYSDATE, -1);
            
--4. 특정 상품코드를 입력 받아 한 달간 해당 상품의 판매 현황 리스트 출력
/*---------------------------------------
   주문코드   상품명   수량   금액
---------------------------------------*/
SELECT ODCODE, GONAME, QTY, AMOUNT 
FROM SALESINFO
WHERE GOCODE = '1001' AND STCODE = 'I001' AND
      --ODCODE >= ADD_MONTHS(SYSDATE, -1);
      TO_CHAR(ODCODE, 'YYYYMMDD') >= TO_CHAR(ADD_MONTHS(SYSDATE, -1), 'YYYYMMDD');

/* 2020-10-26 GROUPING 
    1. FUNCTION을 활용한 GROUPING
       : COUNT, SUM, AVG, MIN, MAX
    2. GROUP BY를 활용한 GROUPING
    
    * GROUP BY절을 사용한 경우 GROUP BY절에 사용한 컬럼만이 
      SELECT절에서 호출할 수 있습니다.
*/
SELECT * FROM OT;
-- 주문건수
SELECT COUNT(OT_ODCODE) FROM OT;
SELECT OT_ODCODE, OT_GOCODE
FROM OT
GROUP BY OT_ODCODE;

-- 특정 고객의 주문내역 출력
/*--------------------------------------------
   고객코드   고객명      주문건수   주문총금액
    CM OD     CM          OD       GO * OT    
----------------------------------------------*/
SELECT * FROM CM;
SELECT * FROM OD;
SELECT * FROM OT;
-- STEP 1 고객별 주문 건수
CREATE OR REPLACE VIEW VIEW1
AS
SELECT  OD.OD_CMCODE AS CMCODE,
        CM.CM_NAME AS CMNAME, 
        OD.OD_CODE AS ODCODE
FROM OD INNER JOIN CM ON OD.OD_CMCODE = CM.CM_CODE
GROUP BY OD.OD_CMCODE, CM.CM_NAME, OD.OD_CODE;

-- STEP 2 주문별 주문금액
CREATE OR REPLACE VIEW VIEW2
AS
SELECT  OT.OT_ODCODE AS ODCODE, 
        SUM(GO.GO_PRICE * OT.OT_QTY) AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY OT.OT_ODCODE;

-- STEP 3 고객별 주문건수, 주문총금액 
SELECT CMCODE, CMNAME, COUNT(V1.ODCODE), SUM(AMOUNT)
FROM VIEW1 V1 INNER JOIN VIEW2 V2 ON V1.ODCODE = V2.ODCODE
GROUP BY CMCODE, CMNAME;



/* JOIN과 GROUP BY 활용 예제 */
/* 특정일(특정범위)의 상품별 판매 현황 
    -- 일일 매출현황
    -- 월별 매출현황
    ---------------------------------------------------
      상품코드     상품명       주문건수       매출액
       OT GO        GO           OT        OT * GO
    ---------------------------------------------------
*/
-- STEP 1 VIEW 생성
SELECT * FROM OT WHERE TO_CHAR(OT_ODCODE, 'YYYYMMDD') = '20201015';
SELECT * FROM OT WHERE TO_CHAR(OT_ODCODE, 'YYYYMM') = '202010';

CREATE OR REPLACE VIEW SALESINFO
AS
SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') AS ODCODE,
        OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        COUNT(OT.OT_GOCODE) AS CNT,
        SUM(OT.OT_QTY) AS QTY,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD'), OT.OT_GOCODE, GO.GO_NAME;

SELECT * FROM SALESINFO;
-- STEP2 VIEW 활용
  -- 특정일의 매출현황
  SELECT SUM(AMOUNT)
  FROM SALESINFO
  WHERE ODCODE = '20201013';
  
  -- 특정일의 상품별 매출현황
  SELECT GOCODE, GONAME, CNT, AMOUNT
  FROM SALESINFO 
  WHERE ODCODE = '20201015';
  
  -- 특정범위의 상품별 매출현황
  SELECT GOCODE, GONAME, 
         SUM(CNT) AS CNT, 
         SUM(AMOUNT) AS AMOUNT
  FROM SALESINFO 
  WHERE ODCODE >= '20201013' AND ODCODE <= '20201015'
  GROUP BY GOCODE, GONAME;

  -- 특정 월별 상품별 매출 현황
  SELECT * FROM SALESINFO;
  SELECT GOCODE, GONAME, 
         SUM(CNT) AS CNT, 
         SUM(AMOUNT) AS AMOUNT
  FROM SALESINFO 
  WHERE SUBSTR(ODCODE, 1, 6) = '202010'
  GROUP BY GOCODE, GONAME;
 
  
/* 특정 상품의 월별 매출 추이 
    --------------------------------------
      매출월        주문건수       매출액
    --------------------------------------
*/

SELECT * FROM SALESINFO;
SELECT TO_CHAR(OD_CODE, 'YYYYMMDD'), COUNT(TO_CHAR(OD_CODE, 'YYYYMMDD'))
FROM OD
GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDD');



SELECT  SUBSTR(SI.ODCODE, 1,6) AS SALSEMONTH,
        SI2.CNT,
        SUM(AMOUNT) AS AMOUNT
FROM SALESINFO SI 
     INNER JOIN   
     (SELECT  TO_CHAR(OD_CODE, 'YYYYMM') AS ODDATE, COUNT(*) AS CNT 
        FROM OD GROUP BY TO_CHAR(OD_CODE, 'YYYYMM')) SI2
     ON SUBSTR(SI.ODCODE, 1,6) =  SI2.ODDATE
GROUP BY SUBSTR(SI.ODCODE, 1,6), SI2.CNT;


SELECT * FROM OD;

/* 특정월의 베스트 상품(판매갯수) 현황 
    ------------------------------------------------------
      매출월    상품코드    상품명    주문건수       매출액
    ------------------------------------------------------
*/
CREATE OR REPLACE VIEW BESTVIEW
AS
SELECT SUBSTR(ODCODE, 1, 6) AS SALESMONTH, 
       GOCODE, GONAME,
       SUM(CNT) AS MONTHCNT,
       SUM(QTY) AS QTY,
       SUM(AMOUNT) AS MONTHAMOUNT
FROM SALESINFO
GROUP BY SUBSTR(ODCODE, 1, 6), GOCODE, GONAME;



SELECT * FROM BESTVIEW;
SELECT SALESMONTH, MAX(QTY)
            FROM BESTVIEW GROUP BY SALESMONTH;



SELECT SALESMONTH, GOCODE, GONAME, MONTHCNT, QTY, MONTHAMOUNT
FROM BESTVIEW
WHERE (SALESMONTH, QTY) 
        IN(SELECT SALESMONTH, MAX(QTY)
            FROM BESTVIEW GROUP BY SALESMONTH);
            

/* 2020-10-27 */
/* ACCESS PROCESS 
   CLIENT :: REQUEST :: ST_CODE, EM_CODE, EM_PWD
   BACKEND <--> DB
   1. IS EM_CODE?
   2-1. (TRUE) EM_CODE EM_PWD
    3-1. (TRUE) DML :: INSERT --> HISTORY
    3-2.        QL :: SELECT --> EMPLOYEES
         RESPONSE --> [ZZANG'S STORE     훈짱(ALBA)   2020-10-27 10:00:00]
   2-2. (FALSE) FAIL  --> RESPONSE
*/

-- 1. IS EM_CODE?  :  EM 
SELECT COUNT(*)
FROM EM WHERE EM_STCODE = 'I001' AND EM_CODE = '1003';  --> 1: 아이디존재   0: 직원 X

-- 2-1. EM_CODE & EM_PWD
SELECT COUNT(*)
FROM EM WHERE EM_STCODE = 'I001' AND EM_CODE = '1003' AND EM_PWD = '1234';

-- 현재 로그인 여부
SELECT SUM(HI_STATE)
FROM HI WHERE HI_EMCODE = '1003' AND HI_EMSTCODE = 'I001';
-- VALUE : 1 :: LOGOUT --> LOGIN
--         0 :: LOGIN

-- 3. INSERT HISTORY
INSERT INTO HI(HI_EMCODE, HI_ACCESSDATE, HI_STATE, HI_EMSTCODE)
VALUES('1003', DEFAULT, 1, 'I001');
INSERT INTO HI(HI_EMCODE, HI_ACCESSDATE, HI_STATE, HI_EMSTCODE)
VALUES('1003', DEFAULT, -1, 'I001');
COMMIT;

SELECT MAX(HI_ACCESSDATE) FROM HI WHERE HI_EMCODE = '1003' AND HI_EMSTCODE = 'I001' AND HI_STATE = 1;

-- 4. EMPLOYEE INFO
/*---------------------------------------------------
[ZZANG'S STORE     훈짱(ALBA)   2020-10-27 10:00:00]
      ST            EM  EM              HI
-----------------------------------------------------
*/
-- STEP 1. EM & ST
SELECT  ST.ST_NAME AS STNAME,
        EM.EM_NAME AS EMNAME,
        EM.EM_LEVEL AS EMLEVEL,
        EM.EM_STCODE AS STCODE,
        EM.EM_CODE AS EMCODE
FROM EM INNER JOIN ST ON EM.EM_STCODE = ST.ST_CODE
WHERE EM.EM_CODE = '1003' AND EM.EM_STCODE = 'I001';

-- STEP 2. INNER JOIN HI
SELECT  ST.ST_NAME AS STNAME,
        EM.EM_NAME AS EMNAME,
        EM.EM_LEVEL AS EMLEVEL,
        HI.HI_ACCESSDATE AS ACCESSDATE,
        EM.EM_STCODE AS STCODE,
        EM.EM_CODE AS EMCODE
FROM EM INNER JOIN ST ON EM.EM_STCODE = ST.ST_CODE
        INNER JOIN HI ON EM.EM_STCODE = HI.HI_EMSTCODE AND EM.EM_CODE = HI.HI_EMCODE
WHERE EM.EM_CODE = '1003' AND EM.EM_STCODE = 'I001' AND HI.HI_STATE = 1;

-- STEP 3  GROUP BY
SELECT  ST.ST_NAME AS STNAME,
        EM.EM_NAME AS EMNAME,
        EM.EM_LEVEL AS EMLEVEL,
        MAX(HI.HI_ACCESSDATE) AS ACCESSDATE,
        EM.EM_STCODE AS STCODE,
        EM.EM_CODE AS EMCODE
FROM EM INNER JOIN ST ON EM.EM_STCODE = ST.ST_CODE
        INNER JOIN HI ON EM.EM_STCODE = HI.HI_EMSTCODE AND EM.EM_CODE = HI.HI_EMCODE
WHERE EM.EM_CODE = '1003' AND EM.EM_STCODE = 'I001' AND HI.HI_STATE = 1
GROUP BY EM.EM_STCODE, ST.ST_NAME, EM.EM_CODE, EM.EM_NAME, EM.EM_LEVEL;


SELECT * FROM EM;
SELECT * FROM HI WHERE HI_EMCODE = '1003';

/* LOGOUT */
/* ACCESS STATE CHECK*/

/* 2020-10-27 
    STEP1. CLIENT에서 요청한 데이터를 소유한 테이블과 컬럼 파악
    *** 그룹함수를 적용할 컬럼이 두 개의 테이블에 각각 위치하고 있다면
        두 개의 테이블을 각각 MAIN TABLE로 지정하여 두 그룹으로 JOIN
        수행 후 두 그룹간에 최종적으로 JOIN수행
    STEP2. JOIN을 수행할 MAIN TABLE을 기준으로 부모 테이블과의 JOIN
            MAIN TABLE이 다대다 테이블인 경우 FK로 참조하는 테이블과의 JOIN
    STEP3. 자식테이블과의 JOIN
            MAIN TABLE이 다대다 테이블인 경우 PK를 전이시킨 테이블과의 JOIN
    STEP4. GROUPING :: 1. FUNCTION  2. GROUP BY
    
    STEP5. VIEW의 활용 :: VIEW는 PARAM이 없음
                         
    
*/
/* 특정일(특정범위)의 상품별 판매 현황 
    -- 일일 매출현황
    -- 월별 매출현황
    ---------------------------------------------------
      상품코드     상품명       주문건수       매출액
 STEP1 OT GO        GO           OT        OT * GO
    ---------------------------------------------------
*/
-- STEP2~3. ORDERDETAIL(OT)
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        OT.OT_ODCODE AS ORDERS,
        OT.OT_QTY * GO.GO_PRICE AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') = '20201015';

-- STEP 4
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        COUNT(OT.OT_ODCODE) AS ORDERS,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') = '20201015'
GROUP BY OT.OT_GOCODE, GO.GO_NAME;

-- 특정 월의 매출현황
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        COUNT(OT.OT_ODCODE) AS ORDERS,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMM') = '202010'
GROUP BY OT.OT_GOCODE, GO.GO_NAME;

-- 특정 범위(일, 월)의 매출현황

SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        COUNT(OT.OT_ODCODE) AS ORDERS,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMM') >= '202009' AND 
      TO_CHAR(OT.OT_ODCODE, 'YYYYMM') <= '202010'
GROUP BY OT.OT_GOCODE, GO.GO_NAME;


/*WHERE TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') >= '20201001' AND
      TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') <= '20201015'*/

-- STEP 5
CREATE OR REPLACE VIEW SALESINFO
AS
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        OT.OT_ODCODE AS ORDERS,
        OT.OT_QTY * GO.GO_PRICE AS AMOUNT 
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;

-- 특정 일의 매출현황
SELECT GOCODE, GONAME, COUNT(ORDERS), SUM(AMOUNT)
FROM SALESINFO
WHERE TO_CHAR(ORDERS, 'YYYYMMDD') = '20201015'
GROUP BY GOCODE, GONAME;

-- 특정 월의 매출현황
SELECT GOCODE, GONAME, COUNT(ORDERS), SUM(AMOUNT)
FROM SALESINFO
WHERE TO_CHAR(ORDERS, 'YYYYMM') = '202010'
GROUP BY GOCODE, GONAME;

-- 특정 범위(일, 월)의 매출현황
SELECT GOCODE, GONAME, COUNT(ORDERS), SUM(AMOUNT)
FROM SALESINFO
WHERE TO_CHAR(ORDERS, 'YYYYMMDD') >= '20200920' AND
      TO_CHAR(ORDERS, 'YYYYMMDD') <= '20201015'
GROUP BY GOCODE, GONAME;


SELECT GOCODE, GONAME, COUNT(ORDERS), SUM(AMOUNT)
FROM SALESINFO
WHERE TO_CHAR(ORDERS, 'YYYYMM') >= '202009' AND
      TO_CHAR(ORDERS, 'YYYYMM') <= '202010'
GROUP BY GOCODE, GONAME;


/* 특정 상품(GOCODE)의 월별 매출 추이 
    --------------------------------------
      매출월        주문건수       매출액
      OD OT           OT        OT * GO
    --------------------------------------
*/
SELECT  TO_CHAR(ORDERS, 'YYYYMM') AS ORDERS,
        COUNT(ORDERS) AS CNT,
        SUM(AMOUNT) AS TOTAMOUNT
FROM SALESINFO
WHERE GOCODE = '3001'
GROUP BY TO_CHAR(ORDERS, 'YYYYMM');

/* 월별 매출 추이 
    --------------------------------------
      매출월        주문건수       매출액
      OD OT      CONUNT(OD)    SUM(OT * GO)
    --------------------------------------
*/
-- GROUPING 1
SELECT  TO_CHAR(OD_CODE, 'YYYYMM') AS SALESMONTH, 
        COUNT(OD_CODE) AS SALESCOUNT
FROM OD
GROUP BY TO_CHAR(OD_CODE, 'YYYYMM');

-- GROUPING 2
SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMM') AS SALESMONTH,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY TO_CHAR(OT.OT_ODCODE, 'YYYYMM');

-- JOIN 
SELECT SI1.SALESMONTH, SI1.SALESCOUNT, SI2.AMOUNT
FROM (SELECT  TO_CHAR(OD_CODE, 'YYYYMM') AS SALESMONTH, COUNT(OD_CODE) AS SALESCOUNT
        FROM OD
        GROUP BY TO_CHAR(OD_CODE, 'YYYYMM')) SI1
INNER JOIN 
     (SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMM') AS SALESMONTH,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
        FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
        GROUP BY TO_CHAR(OT.OT_ODCODE, 'YYYYMM')) SI2
ON SI1.SALESMONTH = SI2.SALESMONTH;


/* 특정월(ODCODE)의 베스트 상품(판매갯수) 현황 
    ------------------------------------------------------
      매출월    상품코드    상품명    판매량       매출액
        OT      OT  GO      GO       OT         OT*GO
    ------------------------------------------------------
*/       
-- STEP 2~3 JOIN  --> VIEW
SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMM') AS SALESMONTH,
        OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        OT.OT_QTY AS QTY,
        OT.OT_QTY * GO.GO_PRICE AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;

-- STEP 4 GROUPING
CREATE OR REPLACE VIEW MONTHLYBEST
AS
SELECT  TO_CHAR(OT.OT_ODCODE, 'YYYYMM') AS SALESMONTH,
        OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        SUM(OT.OT_QTY) AS QTY,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY TO_CHAR(OT.OT_ODCODE, 'YYYYMM'), OT.OT_GOCODE, GO.GO_NAME;


SELECT * 
FROM MONTHLYBEST
WHERE (SALESMONTH, QTY) IN(SELECT SALESMONTH, MAX(QTY) 
                            FROM MONTHLYBEST 
                            GROUP BY SALESMONTH);

/* 시간대별 매출추이 
    --------------------------------
      시간     평균주문건수  평균매출액
      OD OT       OD          OT*GO
    --------------------------------
*/
-- GROUPING1 --> 일별 시간별 합산
SELECT  TO_CHAR(OD_CODE, 'YYYYMMDDHH24') AS SALESDAYTIME, 
        COUNT(OD_CODE) AS ORDERS
FROM OD
GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDDHH24');

-- GROUPING1 --> 시간대 별 평균 주문 추출
SELECT SUBSTR(SALESDAYTIME, 9,2) AS SALESTIME, 
       TO_CHAR(ROUND(AVG(ORDERS),1), '9,990.0') AS ORDERSAVG
FROM (SELECT  TO_CHAR(OD_CODE, 'YYYYMMDDHH24') AS SALESDAYTIME, 
              COUNT(*) AS ORDERS
      FROM OD
      GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDDHH24'))
GROUP BY SUBSTR(SALESDAYTIME, 9,2);

-- GROUPING2 :: 일별 시간별 합산
SELECT  TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24') AS SALESDAYTIME,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS DAYAVG
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24');

-- GROUPING2 --> 시간별 평균
SELECT  SUBSTR(SALESDAYTIME, 9,2) AS SALESTIME,
        TO_CHAR(ROUND(AVG(DAYAMOUNT), 1), '999,990.0') AS AMOUNTAVG
FROM (SELECT  TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24') AS SALESDAYTIME,
              SUM(OT.OT_QTY * GO.GO_PRICE) AS DAYAMOUNT
      FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
      GROUP BY TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24'))
GROUP BY SUBSTR(SALESDAYTIME, 9,2);

-- GROUPING1 JOIN GROUPING2
SELECT GR1.SALESTIME || ' TIME' AS SALESTIME,
       GR1.ORDERSAVG AS ORDERSAVG,
       GR2.AMOUNTAVG AS AMOUNTAVG
FROM (SELECT SUBSTR(SALESDAYTIME, 9,2) AS SALESTIME, 
             TO_CHAR(ROUND(AVG(ORDERS),1), '9,990.0') AS ORDERSAVG
      FROM (SELECT  TO_CHAR(OD_CODE, 'YYYYMMDDHH24') AS SALESDAYTIME, 
                    COUNT(*) AS ORDERS
            FROM OD
            GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDDHH24'))
        GROUP BY SUBSTR(SALESDAYTIME, 9,2)) GR1
INNER JOIN 
     (SELECT  SUBSTR(SALESDAYTIME, 9,2) AS SALESTIME,
              TO_CHAR(ROUND(AVG(DAYAMOUNT), 1), '999,990.0') AS AMOUNTAVG
      FROM (SELECT  TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24') AS SALESDAYTIME,
                    SUM(OT.OT_QTY * GO.GO_PRICE) AS DAYAMOUNT
            FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
            GROUP BY TO_CHAR(OT_ODCODE, 'YYYYMMDDHH24'))
        GROUP BY SUBSTR(SALESDAYTIME, 9,2)) GR2
ON GR1.SALESTIME = GR2.SALESTIME;


/* 요일별 매출추이 
    --------------------------------
      요일     평균주문건수  평균매출액
    --------------------------------
*/
CREATE OR REPLACE VIEW V1
AS
SELECT SALESDAY AS SALESDAY, 
       TO_CHAR(ROUND(AVG(ORDERS),1), '9,990.0') AS ORDERSAVG
FROM (SELECT  TO_CHAR(OD_CODE, 'YYYYMMDD') AS SALESDATE,
              TO_CHAR(OD_CODE, 'DAY') AS SALESDAY,
              COUNT(*) AS ORDERS
      FROM OD
      GROUP BY TO_CHAR(OD_CODE, 'YYYYMMDD'),TO_CHAR(OD_CODE, 'DAY'))
GROUP BY SALESDAY;

CREATE OR REPLACE VIEW V2
AS
SELECT  SALESDAY AS SALESDAY,
        TO_CHAR(ROUND(AVG(DAYAMOUNT), 1), '999,990.0') AS AMOUNTAVG
FROM (SELECT  TO_CHAR(OT_ODCODE, 'YYYYMMDD') AS SALESDATE,
              TO_CHAR(OT_ODCODE, 'DAY') AS SALESDAY,
              SUM(OT.OT_QTY * GO.GO_PRICE) AS DAYAMOUNT
      FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
      GROUP BY TO_CHAR(OT_ODCODE, 'YYYYMMDD'), TO_CHAR(OT_ODCODE, 'DAY'))
GROUP BY SALESDAY;

SELECT V1.SALESDAY, V1.ORDERSAVG, V2.AMOUNTAVG
FROM V1 INNER JOIN V2 ON V1.SALESDAY = V2.SALESDAY;

/* 2020-10-28 OUTER JOIN 
   OUTER JOIN
    - 두 개의 테이블에 공통된 데이터를 가진 컬럼이 존재
    - [LEFT | RIGHT | FULL] OUTER JOIN
       지정한 방향의 테이블의 데이터는 조인 조건에 만족하지 않아도 강제 출력
    - NULL DATA의 회피 강구
      -- NVL, NVL2, * COALESCE() 
*/
-- 상품별 매출현황
/*--------------------------------------------
   상품코드   상품명    판매량     총매출액
---------------------------------------------*/
SELECT * FROM GO;
SELECT * FROM OT;

SELECT  GO.GO_CODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        SUM(COALESCE(OT.OT_QTY, 0)) AS QTY,
        SUM(COALESCE(OT.OT_QTY * GO.GO_PRICE, 0)) AS AMOUNT
FROM OT RIGHT OUTER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY GO_CODE, GO.GO_NAME;

/* OUTER JOIN의 활용예제 */
/* 1. 특정 상점의 직원의 로그인과 로그아웃 횟수 기록 출력 
    ---------------------------------------------
      사원코드   사원명   로그인횟수   로그아웃 횟수
    ---------------------------------------------
*/ 
-- STEP 1. 로그인-아웃 횟수 조회
SELECT HI_EMSTCODE AS STCODE, HI_EMCODE AS EMCODE, COUNT(HI_STATE) AS INCNT
FROM HI 
WHERE HI_STATE = 1
GROUP BY HI_EMSTCODE, HI_EMCODE;

SELECT HI_EMSTCODE AS STCODE, HI_EMCODE AS EMCODE, COUNT(HI_STATE) AS OUTCNT
FROM HI 
WHERE HI_STATE = -1
GROUP BY HI_EMSTCODE, HI_EMCODE;

-- STEP 2. STEP1에서 조회한 QUERY를 FULL OUTER 조인 후 VIEW 생성
CREATE OR REPLACE VIEW ACCESSINFO
AS
SELECT  COALESCE(LI.STCODE, LO.STCODE) AS STCODE,
        COALESCE(LI.EMCODE, LO.EMCODE) AS EMCODE,
        COALESCE(LI.INCNT, 0) AS INCNT,
        COALESCE(LO.OUTCNT, 0) AS OUTCNT
FROM (SELECT HI_EMSTCODE AS STCODE, HI_EMCODE AS EMCODE, COUNT(HI_STATE) AS INCNT
      FROM HI 
      WHERE HI_STATE = 1
      GROUP BY HI_EMSTCODE, HI_EMCODE) LI
     FULL OUTER JOIN 
     (SELECT HI_EMSTCODE AS STCODE, HI_EMCODE AS EMCODE, COUNT(HI_STATE) AS OUTCNT
      FROM HI 
      WHERE HI_STATE = -1
      GROUP BY HI_EMSTCODE, HI_EMCODE) LO
     ON LI.STCODE = LO.STCODE AND LI.EMCODE = LO.EMCODE;

SELECT * FROM ACCESSINFO;
-- STEP 3. EMPLOYEES 테이블과의 조인
SELECT EM.EM_STCODE AS STCODE, 
       EM.EM_CODE AS EMCODE,
       EM.EM_NAME AS EMNAME,
       COALESCE(AC.INCNT,0) AS INCNT, 
       COALESCE(AC.OUTCNT, 0) AS OUTCNT
FROM EM LEFT OUTER JOIN ACCESSINFO AC 
ON EM.EM_STCODE = AC.STCODE AND EM.EM_CODE = AC.EMCODE;

/* 2. 특정 상점의 모든 직원중 로그인 횟수가 가장 많은 직원의 정보 출력 
    ----------------------------------------
      사원코드   사원명   로그인횟수   사원등급
    ----------------------------------------
    *** 출력 컬럼에 로그인 횟수가 없다면 SUB-QUERY로만 진행
*/ 
SELECT EM.EM_STCODE, EM.EM_CODE, AI.INCNT, EM.EM_LEVEL 
FROM ACCESSINFO AI INNER JOIN EM 
ON AI.STCODE = EM.EM_STCODE AND AI.EMCODE = EM.EM_CODE
WHERE INCNT IN (SELECT MAX(INCNT) FROM ACCESSINFO);

-- 로그인 횟수가 없는 경우
SELECT EM_STCODE, EM_CODE, EM_LEVEL 
FROM EM 
WHERE (EM_STCODE, EM_CODE) IN(SELECT STCODE, EMCODE 
                                FROM ACCESSINFO 
                                WHERE INCNT IN (SELECT MAX(INCNT) FROM ACCESSINFO));

/* 3. 특정 상점의 모든 직원을 대상으로 직원별 판매실적을 출력
    ----------------------------------------
      사원코드   사원명   주문건수    매출액
    ----------------------------------------
    *** 주문코드와 사원은 1:1
*/ 
-- STEP 1. 주문별 매출액 합계
SELECT  OT.OT_ODCODE AS ODCODE,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
GROUP BY OT.OT_ODCODE;

-- STEP 2. 주문테이블과의 조인후 VIEW 생성
CREATE OR REPLACE VIEW SALES
AS
SELECT  OD.OD_EMSTCODE AS STCODE,
        OD.OD_EMCODE AS EMCODE,
        OT.OT_ODCODE AS ODCODE,
        SUM(OT.OT_QTY * GO.GO_PRICE) AS AMOUNT
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE
        INNER JOIN OD ON OT.OT_ODCODE = OD.OD_CODE
GROUP BY OD.OD_EMSTCODE, OD.OD_EMCODE, OT.OT_ODCODE;

-- STEP 3. 사원테이블과의 OUTER JOIN
SELECT  COALESCE(SA.STCODE, EM.EM_STCODE) AS STCODE,
        COALESCE(SA.EMCODE, EM.EM_CODE) AS EMCODE,
        EM.EM_NAME AS EMNAME,
        SA.ODCODE, SA.AMOUNT
FROM SALES SA RIGHT OUTER JOIN EM
           ON SA.STCODE = EM.EM_STCODE AND SA.EMCODE = EM.EM_CODE;

-- STEP 4. GROUP BY
SELECT  COALESCE(SA.STCODE, EM.EM_STCODE) AS STCODE,
        COALESCE(SA.EMCODE, EM.EM_CODE) AS EMCODE,
        EM.EM_NAME AS EMNAME,
        COUNT(SA.ODCODE) AS ORDERS, 
        TO_CHAR(SUM(COALESCE(SA.AMOUNT,0)), '9,999,990') AS TOTAMOUNTS
FROM SALES SA RIGHT OUTER JOIN EM
           ON SA.STCODE = EM.EM_STCODE AND SA.EMCODE = EM.EM_CODE
GROUP BY COALESCE(SA.STCODE, EM.EM_STCODE), 
         COALESCE(SA.EMCODE, EM.EM_CODE), EM.EM_NAME;
         
/* 4. 모든 상품의 정보 출력
    --------------------------------------------
      상품코드   상품명   가격    재고     유통기한
    --------------------------------------------
*/ 

/* 5. 4의 결과중 판매가능한 상품정보를 출력
    --------------------------------------------
      상품코드   상품명   가격    재고     유통기한
    --------------------------------------------
*/ 
INSERT INTO EM(EM_STCODE, EM_CODE, EM_NAME, EM_PWD, EM_LEVEL)
VALUES('I001', '9999', 'GHOST', '1234', 'A');

/* 1. 직원코드 존재여부 :: STCODE, EMCODE */
SELECT COUNT(*) AS ISEMCODE FROM EM WHERE EM_STCODE = 'I001' AND EM_CODE = '1003';

SELECT * FROM EM WHERE 1=2;
SELECT * FROM HI;
INSERT INTO HI(HI_EMSTCODE, HI_EMCODE, HI_ACCESSDATE, HI_STATE) VALUES('I001', '1003', TO_DATE('20201029110400', 'YYYYMMDDHH24MISS'), 1);

/* Get Access Info */
CREATE OR REPLACE VIEW ACCESSINFO
AS
SELECT  EM.EM_STCODE AS STCODE,
        EM.EM_NAME AS EMNAME, 
        EM.EM_CODE AS EMCODE,
        EM.EM_LEVEL AS EMLEVEL,
        MAX(TO_CHAR(HI.HI_ACCESSDATE, 'YYYYMMDDHH24MISS')) AS ACCESSTIME
FROM HI INNER JOIN EM 
ON HI.HI_EMSTCODE = EM.EM_STCODE AND HI.HI_EMCODE = EM.EM_CODE
GROUP BY EM.EM_STCODE, EM.EM_NAME, EM.EM_CODE, EM.EM_LEVEL;

SELECT * FROM ACCESSINFO WHERE STCODE = 'I001' AND EMCODE = '1003';

SELECT * FROM EM;

/* 일일 매출 */
CREATE OR REPLACE VIEW DAILYSALES
AS
SELECT  OT.OT_GOCODE AS GOCODE,
        GO.GO_NAME AS GONAME,
        GO.GO_PRICE AS GOPRICE,
        OT.OT_QTY AS QTY,
        GO.GO_PRICE * OT.OT_QTY AS AMOUNT,
        TO_CHAR(OT.OT_ODCODE, 'YYYYMMDD') AS ORDERDATE
FROM OT INNER JOIN GO ON OT.OT_GOCODE = GO.GO_CODE;

SELECT GOCODE, GONAME, GOPRICE, SUM(QTY), SUM(AMOUNT)
FROM DAILYSALES
WHERE ORDERDATE = '20201015'
GROUP BY GOCODE, GONAME, GOPRICE;


/* 2020-10-30 Trigger 
    - DML이 수행되기 전|후에 수행되는 IMPLIED PROCEDURE
    - TABLE에 대해서만 정의
    SYNTAX______________________
    CREATE OR REPLACE TRIGGER [TRIG_NAME]
     [BEFORE | AFTER]
     [TIRGERR_EVENT] ON [TAB_NAME]  ---> INSERT, UPDATE, DELETE
     FOR EACH ROW
     [WHEN CONDITION]
    BEGIN
        EXECUTION-STATEMENTS
    END;
*/
SELECT * FROM GO;
SELECT * FROM SC;
SELECT * FROM OT;
SELECT * FROM HOONZZANG.ORDERDETAIL;
-- 상품판매 시 재고정보 UPDATE
/*CREATE OR REPLACE TRIGGER UPD_STOCKS
  AFTER INSERT ON HOONZZANG.ORDERDETAIL
  FOR EACH ROW
 
  DECLARE
    
  BEGIN
    UPDATE SC SET SC_STOCKS = (SC_STOCKS - :NEW.OT_QTY) WHERE SC_GOCODE = :NEW.OT_GOCODE;
  END UPD_STOCKS;
*/
SET SERVEROUTPUT ON;
UPDATE SC SET SC_STOCKS = (SC_STOCKS - :NEW.OT_QTY) 
    WHERE SC_GOCODE = :NEW.OT_GOCODE;
-- 상품등록
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS)
VALUES('9999', 'TEST', 1000, NULL);
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE)
VALUES('9999', DEFAULT, 100, SYSDATE+2);
COMMIT;
SELECT * FROM GO;
SELECT * FROM SC;

-- 상점 및 직원 등록
SELECT * FROM ST;
INSERT INTO ST(ST_CODE, ST_NAME, ST_ADDR) VALUES('I001', 'TEST STORE', '인천');
SELECT * FROM EM;
INSERT INTO EM(EM_STCODE, EM_CODE, EM_PWD, EM_NAME) 
VALUES('I001', '9999', '1234', 'HOON');
COMMIT;

SELECT * FROM CM;
INSERT INTO CM(CM_CODE, CM_NAME, CM_PHONE) VALUES('7777', '다사요', '01056808050');
COMMIT;
-- 주문등록
SELECT * FROM OD;
INSERT INTO OD(OD_CODE, OD_EMSTCODE, OD_EMCODE, OD_CMCODE, OD_STATE) 
VALUES(DEFAULT, 'I001', '9999', '7777', 'P');
INSERT INTO OT(OT_ODCODE, OT_GOCODE, OT_QTY, OT_STATE) 
VALUES('20201030134418', '9999', 10, 'P');
SELECT * FROM OT;
DELETE FROM OT;
COMMIT;
SELECT * FROM SC;
ROLLBACK;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='EMPLOYEES';


/* 2020-11-02 Procedure */
CREATE OR REPLACE PROCEDURE REG_ORDER
 (STCODE    IN OD.OD_EMSTCODE%TYPE,
  EMCODE    IN OD.OD_EMCODE%TYPE,
  CMCODE    IN OD.OD_CMCODE%TYPE,
  ODSTATE   IN OD.OD_STATE%TYPE
  ODCODE    OUT NVARCHAR2)
 IS
 
 BEGIN
    INSERT INTO OD(OD_CODE, OD_EMSTCODE, OD_EMCODE, OD_CMCODE, OD_STATE) 
    VALUES(DEFAULT, STCODE, EMCODE, CMCODE, ODSTATE);

    SELECT TO_CHAR(MAX(OD_CODE), 'YYYYMMDDHH24MISS') INTO ODCODE
    FROM OD 
    WHERE OD_EMSTCODE = STCODE AND OD_EMCODE = EMCODE;
 END REG_ORDER;
 
 

SET SERVEROUTPUT ON;

DECLARE
    ODCODE NVARCHAR2(14);
BEGIN
    REG_ORDER('I001', '9999', '7777', 'P', ODCODE);
    DBMS_OUTPUT.PUT_LINE('ODCODE : ' || ODCODE);
END;

SELECT * FROM OD WHERE OD_CODE = '20201102111446';
ROLLBACK;
DELETE FROM OD;
DELETE FROM OT;
SELECT * FROM EM;
SELECT * FROM CM;

/*
public String regOrder(String stCode, String emCode, String cmCode, String state) {
		String odCode = null;
		CallableStatement proc;
		String sql = "{call REG_ORDER(?, ?, ?, ?, ?)}";
		
		try {
			proc = conn.prepareCall(sql);
			proc.setNString(1, stCode);
			proc.setNString(2, emCode);
			proc.setNString(3, cmCode);
			proc.setNString(4, state);
			proc.registerOutParameter(5, Types.NVARCHAR);
			
			proc.execute();
			odCode = proc.getString(5);
			
			proc.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return odCode;
	}

*/
/* 2020-11-02 Procedure :: INS_OT 
    :: PARAM
    @ODCODE IN
    @GOCODE IN
    @GOQTY  IN
    @OTSTATE  IN
*/
CREATE OR REPLACE PROCEDURE INS_OT(
  ODCODE    IN  NVARCHAR2,
  GOCODE    IN  OT.OT_GOCODE%TYPE,
  GOQTY     IN  OT.OT_QTY%TYPE,
  OTSTATE   IN  OT.OT_STATE%TYPE
)
IS

BEGIN
    INSERT INTO OT(OT_ODCODE, OT_GOCODE, OT_QTY, OT_STATE) 
    VALUES(TO_DATE(ODCODE, 'YYYYMMDDHH24MISS'), GOCODE, GOQTY, OTSTATE);
END INS_OT;


SET SERVEROUTPUT ON;

DECLARE
  ODCODE    NCHAR(14) := '20201102111446';
  GOCODE    NCHAR(4)  := '9999';
  QTY       NUMBER    := 2;
  OTSTATE   NCHAR(1)  := 'P';
BEGIN
  INS_OT(ODCODE, GOCODE, QTY, OTSTATE);
  SELECT OT_ODCODE, OT_GOCODE, OT_QTY, OT_STATE 
  INTO ODCODE, GOCODE, QTY, OTSTATE
  FROM OT WHERE OT_ODCODE = '20201102111446';
  
  DBMS_OUTPUT.PUT_LINE('ODCODE : ' || ODCODE);
  DBMS_OUTPUT.PUT_LINE('GOCODE : ' || GOCODE);
  DBMS_OUTPUT.PUT_LINE('QTY : ' || QTY);
  DBMS_OUTPUT.PUT_LINE('STATE : ' || OTSTATE);
END;

SELECT * FROM GO;
SELECT * FROM OT;

INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) 
VALUES('9998', '새우깡', 1500, '가정용');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) 
VALUES('9997', '새우깡', 3500, '대용량');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) 
VALUES('9996', '양파깡', 2000, '가정용');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) 
VALUES('9995', '양파깡', 5000, '대용량');
COMMIT;


SELECT * FROM OD;
SELECT * FROM OT;

/* APPLICATION CODE
// Bean Creation :: backController
		--OrdersBean ob = new OrdersBean();
		--ob.setStCode("I001");
		--ob.setEmCode("9999");
		--ob.setCmCode("7777");
		--ob.setOrderState("C");
		
		// 상품정보 입력 Bean Creation :: backController
		// ArrayList<OrdersBean> list 담기 :: backController
		ArrayList<OrdersBean> list = new ArrayList<OrdersBean>();
		OrdersBean ob1 = new OrdersBean();
		// first Goods
		ob1.setStCode("I001");
		ob1.setEmCode("9999");
		ob1.setCmCode("7777");
		ob1.setOrderState("C");
		ob1.setGoCode("9998");
		ob1.setQty(10);
		ob1.setGoState("P");
		list.add(ob1);
		
		// Second Goods
		OrdersBean ob2 = new OrdersBean();
		ob2.setStCode("I001");
		ob2.setEmCode("9999");
		ob2.setCmCode("7777");
		ob2.setOrderState("C");
		ob2.setGoCode("9997");
		ob2.setQty(10);
		ob2.setGoState("P");
		list.add(ob2);
		
		// Third Goods
		OrdersBean ob3 = new OrdersBean();
		ob3.setStCode("I001");
		ob3.setEmCode("9999");
		ob3.setCmCode("7777");
		ob3.setOrderState("C");
		ob3.setGoCode("9996");
		ob3.setQty(10);
		ob3.setGoState("P");
		list.add(ob3);
		
		// list --> Service
		DataAccessObject dao = new DataAccessObject();
		
		dao.createConnection();
		dao.setAutoTran(false);
		
		dao.regOrder(list.get(0));
		
		// list(0)에 담겨온 OdCode list(1), list(2)복사
		list.get(1).setOdCode(list.get(0).getOdCode());
		list.get(2).setOdCode(list.get(0).getOdCode());
		
		// OT 상품 등록
		boolean tran = false;
		for(OrdersBean ob : list) {
			if(dao.insOrder(ob)) {
				tran = true;
			}else {
				tran = false;
				break;
			}
		}
		if(tran) {
			// Orders Table에 OD_STATE 값을 'P' 로 업데이트
		}
		
		dao.endTransaction(tran);
		if(tran) {
			System.out.println("주문성공");
		}else {
			System.out.println("주문실패");
		}
*/